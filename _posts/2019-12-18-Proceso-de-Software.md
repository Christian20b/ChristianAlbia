---
layout: post
title: "Proceso del Software"
author: "Christian Albia"
categories: journal
tags: [documentation,sample]
image: forest.jpg
---

## El proceso del Software

  <p>•  Conjunto de actividades necesarias para transformar las ideas iniciales del usuario, que desea automatizar un determinado trabajo, en software.</p>
  <p>•  Conjunto ordenado de actividades; una serie de pasos que involucran tareas, restricciones y recursos que producen una determinada salida esperada.</p>
  <p>•  Marco de trabajo de las tareas que se requieren para construir software de alta calidad.</p>
  <p>•  Un conjunto estructurado de actividades necesarias para desarrollar un sistema de software.</p>
  <p>Muchos de los procesos de software son diferentes, pero todos implican:</p>
  <p>-Especificación;</p>
  <p>-Diseño e implementación;</p>
  <p>-Validación;</p>
  <p>-Evolución.</p>





## Características del proceso de SW

  <p>Cualquier proceso tiene las siguientes características:</p>
  <p>•  El proceso establece todas las actividades principales.</p>
  <p>•  El proceso utiliza recursos, está sujeto a una serie de restricciones y genera productos intermedios y finales</p>
  <p>•  El proceso puede estar compuesto de subprocesos que se encadenan de alguna manera. Puede definirse como una jerarquía de procesos organizada de modo que cada subproceso tenga su propio modelo de proceso</p>
  <p>•  Cada actividad del proceso tiene criterios de entrada y de salida, de modo que se conoce cuándo comienza y cuándo termina una actividad.</p>
  <p>•  Las actividades se organizan en secuencia de modo que resulta claro cuando una actividad se realiza en orden relativo a otras actividades.</p>
  <p>•  Todo proceso tiene un conjunto de principios orientadores que explican las metas de cada actividad.</p>
  <p>•  Las restricciones o controles pueden aplicarse a una actividad, recurso o producto</p>

## Otras características del proceso de SW

  <p>•  Comprensión</p>
  <p>-Está definido y es comprensible</p>
  <p>•  Visibilidad </p>
  <p>-Se visualizan los progresos externamente</p>
  <p>•  Soporte</p>
  <p>-Está soportado por herramientas CASE</p>
  <p>•  Aceptación</p>
  <p>-Es aceptable para todos los actores implicados</p>
  <p>•  Confianza </p>
  <p>-Los errores del proceso se detectan antes de que se produzcan errores en el producto</p>
  <p>•  Robustez </p>
  <p>-Se puede continuar a pesar de problemas inesperados</p>
  <p>•  Capacidad de mantenimiento </p>
  <p>-Puede ajustarse a las necesidades de cambio de la organización</p>
  <p>•  Rapidez</p>
  <p>-Con qué “velocidad” se producen los sistemas</p>
  <p>•  Adaptación </p>
  <p>-Capacidad que tiene un usuario del mismo de adaptarlo a sus necesidades</p>



## Importancia del proceso de SW


  <p>Un proceso software debe especificar:</p>
  <p>•  La secuencia de actividades a realizar por el equipo de desarrollo</p>
  <p>-Flujo de actividades</p>
  <p>•  Los productos que deben crearse</p>
  <p>-Resultados del trabajo (modelos, documentos, datos informes...) </p>
  <p>-Qué y cuándo</p>
  <p>•  La asignación de tareas a cada miembro del equipo y al equipo como un todo</p>
  <p>Los criterios para controlar el proceso </p>
  <p>•  Se establece el control de gestión de los proyectos software </p>
  <p>•  Establecimiento de hitos </p>
  <p>Las posibles heurísticas</p>
  <p>•  Facilita la gestión del proyecto </p>
  <p>•  Establece una división del trabajo</p>
  <p>•  Facilita la comunicación de los miembros del equipo</p>
  <p>•  Permite la reasignación y la reutilización de personal especializado</p>
  <p>-Transferencia entre proyectos</p>
  <p>•  Mejora la productividad y el desarrollo </p>
  <p>-El desarrollo es reproducible</p>
  <p>•  Establece el contexto en el que se aplican los métodos técnicos </p>
  <p>•  Gestiona el cambio adecuadamente </p>
  <p>•  Asegura la calidad</p>


### Estándares relacionados con el proceso de SW

<h3> Estándar ISO/IEC/IEEE 12207:2017 </h3>

  <p>•  El estándar ISO/IEC/IEEE 12207:2017 [ISO/IEC/IEEE, 2017] relativo a los procesos del ciclo de vida del software</p>
  <p>•  Se aplica a la adquisición de sistemas de software, productos y servicios, al suministro, desarrollo, operación, mantenimiento y eliminación de productos de software o componentes de software de cualquier sistema, ya sea que se realice interna o externamente a una organización.</p>
  <p>•  Se incluyen aquellos aspectos de la definición del sistema necesarios para proporcionar el contexto de los productos y servicios de software.</p>
  <p>•  También proporciona procesos que pueden emplearse para definir, controlar y mejorar los procesos del ciclo de vida del software dentro de una organización o de un proyecto.</p>
  <p>•  Esta norma no fomenta o especifica ningún modelo concreto de ciclo de vida, gestión del software o método de ingeniería, ni prescribe cómo realizar ninguna de las actividades.</p>              

### Ciclo de vida del SW

   <p>•  Cuando un proceso implica la construcción de algún producto, suele referirse al proceso como un ciclo de vida</p>
   <p>-El proceso de desarrollo de software suele denominarse ciclo de vida del software</p>
   <p>•  La evolución del software representa el ciclo de ac7vidades involucradas en el desarrollo, uso y mantenimiento de sistemas software [Scacchi, 1987].</p>
   <p>•  Los proyectos software se desarrollan en una serie de fases.</p>
   <p>-Van desde la concepción del software y su desarrollo inicial hasta su puesta en funcionamiento y posterior retirada por otra nueva generación de software</p>
   <p>Estas fases pueden ser:</p>
   <p>-Temporales.- Forman una secuencia en el tiempo</p>
   <p>-Lógicas.- Cuando representan pasos o etapas que no constituyen una secuencia temporal</p>
   <p>Se puede definir ciclo de vida del software como:</p>
   <p>-Las distintas fases por las que pasa el software desde que nace una necesidad de mecanizar un proceso hasta que deja de utilizarse el software que sirvió para ese objetivo, pasando por las fases de desarrollo y explotación [Frakes et al., 1991]</p>
   <p>-El período de tiempo que comienza cuando se concibe un producto software y finaliza cuando el producto pierde su utilidad. El ciclo de vida del software incluye las siguientes fases: fase de requisitos, fase de diseño, fase de realización, fase de pruebas, fase de instalación y aceptación, fase de operación y mantenimiento y, algunas veces, fase de retirada [AECC, 1986]</p>
   <p>-Un marco de referencia que contiene los procesos, las actividades y las tareas involucradas en el desarrollo, la explotación y el mantenimiento de un producto de software, abarcando la vida del sistema desde la definición de requisitos hasta la finalización de su uso [ISO/IEC, 2008]</p>
   <p>-Una aproximación lógica a la adquisición, el suministro, el desarrollo, la explotación y el mantenimiento del software IEEE Std 1074-1997 Standard for Developing Software Life Cycle Processes [IEEE, 1999b]</p>
   <p>-El ciclo de vida del software consiste de las siguientes fases: análisis de requisitos, diseño, implementación, prueba y mantenimiento. El proceso de desarrollo tiende a una iteración de estas fases más que a un proceso lineal [CERN, 1996].</p>
   <p>-El ciclo de vida del software usa el modelo de que un elemento software tiene vida. Un elemento software tiene una fase de concepción (una idea en una mente de un usuario potencial), después de una fase de gestación (la fase de desarrollo del software) hacia una fase de madurez (la revisión y corrección de errores, o fase de mantenimiento), y finalmente la fase de retirada [Leaney, 2004]</p>
   <p>Se puede definir ciclo de desarrollo del software como:</p>
   <p>-El período de tiempo que comienza con la decisión de desarrollar un producto software y finaliza cuando se ha entregado éste. Este ciclo incluye, en general, una fase de requisitos, una fase de diseño, una fase de implantación, una fase de pruebas, y a veces, una fase de instalación y aceptación [AECC, 1986]</p>
   



## Ámbito general del ciclo de vida del SW

   <p>Desde un punto de vista general puede considerarse que el ciclo de vida de un software tiene tres etapas claramente diferenciadas:</p>
   <p>•  Planificación: idearemos un planeamiento detallado que guíe la gestión del proyecto, temporal y económicamente.</p>
   <p>•  Implementación: acordaremos el conjunto de actividades que componen la realización del producto.</p>
   <p>•  Puesta en producción: nuestro proyecto entra en la etapa de definición, allí donde se lo presentamos al cliente o usuario final, sabiendo que funciona correctamente y responde a los requerimientos solicitados en su momento. Esta etapa es muy importante no sólo por representar la aceptación o no del proyecto por parte del cliente o usuario final sino por las múltiples dificultades que suele presentar en la práctica, alargándose excesivamente y provocando costos no previstos.</p>

### Objetivos de cada etapa

   <p>En cada una de las etapas de un modelo de ciclo de vida, se pueden establecer una serie de objetivos, tareas y actividades que lo caracterizan.</p>
   <p>•  Expresión de necesidades: esta etapa tiene como objetivo el armado de un documento en el cual se reflejan los requerimientos y funcionalidades que ofrecerá al usuario el sistema a implementar (qué, y no cómo, se va a implementar).</p>
   <p>•  Especificaciones: formalizamos los requerimientos; el documento obtenido en la etapa anterior se tomará como punto de partida para esta etapa.</p>
   <p>•  Análisis: determinamos los elementos que intervienen en el sistema a desarrollar, su estructura, relaciones, evolución temporal, funcionalidades, tendremos una descripción clara de qué producto vamos a construir, qué funcionalidades aportará y qué comportamiento tendrá.</p>
   <p>•  Diseño: ya sabemos qué hacer, ahora tenemos que determinar cómo debemos hacerlo (¿cómo debe ser construido el sistema en cuestión?; definimos en detalle entidades y relaciones de las bases de datos, seleccionamos el lenguaje que vamos a utilizar, el Sistema Gestor de Bases de Datos, etc.).</p>
   <p>•  Implementación: empezamos a codificar algoritmos y estructuras de datos, definidos en las etapas anteriores, en el correspondiente lenguaje de programación o para un determinado sistema gestor de bases de datos. En muchos proyectos se pasa directamente a esta etapa; son proyectos muy arriesgados que adoptan un modelo de ciclo de vida de code & fix (codificar y corregir) donde se eliminan las etapas de especificaciones, análisis y diseño con la consiguiente pérdida de control sobre la gestión del proyecto.</p>
   <p>•  Debugging: el objetivo de esta etapa es garantizar que nuestro programa no contiene errores de diseño o codificación. En esta etapa no deseamos saber si nuestro programa realiza lo que solicitó el usuario, esa tarea le corresponde a la etapa de implementación. En ésta deseamos encontrar la mayor cantidad de errores. Todos los programas contienen errores: encontrarlos es cuestión de tiempo. Lo ideal es encontrar la mayoría, si no todos, en esta etapa. También se pueden agregar testeos de performance.</p>
   <p>•  Validación: esta etapa tiene como objetivo la verificación de que el sistema desarrollado cumple con los requerimientos expresados inicialmente por el cliente y que han dado lugar al presente proyecto. En muchos proyectos las etapas de validación y debugging se realizan en paralelo por la estrecha relación que llevan. Sin embargo, tenemos que evitar la confusión: podemos realizarlos en paralelo, pero no como una única etapa.</p>
   <p>•  Evolución: en la mayoría de los proyectos se considera esta etapa como Mantenimiento y evolución, y se le asigna, no sólo el agregado de nuevas funcionalidades (evolución); sino la corrección de errores que surgen (mantenimiento). En la práctica esta denominación no es del todo errónea, ya que es posible que aun luego de una etapa de debugging y validación exhaustiva, se filtren errores.</p>

### ¿Modelo de Proceso de SW?

   <p>Hay varios modelos de procesos definidos en la bibliografía de Ingeniería del Software</p>
   <p>Cada modelo de proceso representa un proceso desde una perspectiva particular, por lo que sólo ofrece una información parcial sobre dicho proceso.</p>



### Razones para modelar un proceso de SW
   
   <p>•  Cuando se pone por escrito una descripción de un proceso, se da forma a una comprensión común de las actividades, recursos y restricciones relacionados con el desarrollo del software.</p>
   <p>•  Ayuda al equipo de desarrollo a encontrar las inconsistencias, las redundancias y las omisiones en el proceso y en las partes que lo constituyen.</p>
   <p>•  El modelo debe reflejar las metas del desarrollo. A medida que se construye el modelo el equipo de desarrollo evalúa las actividades candidatas por su adecuación para alcanzar dichas metas.</p>
   <p>•  Ayuda al equipo de desarrollo a comprender dónde debe adaptarse el proceso</p>
   <p>•  Los modelos de proceso de desarrollo de software incluyen los requisitos del sistema como entrada y un producto entregado como salida</p>





### Modelo general de proceso en Ingeniería

   <p>•  Especificación</p>
   <p>Formulación de los requisitos y restricciones del sistema </p>
   <p>•  Diseño</p>
   <p>Elaboración de un documento con el modelo del sistema</p>
   <p>•  Fabricación</p>
   <p>Construcción del sistema</p>
   <p>•  Prueba</p>
   <p>Comprobación de que el sistema cumple las especificaciones requeridas</p>
   <p>•  Instalación</p>
   <p>Entrega del sistema al cliente y garantía de que es operativo</p>
   <p>•  Mantenimiento</p>
   <p>Reparación de los fallos que aparecen en el sistema</p>
   <p></p>
   <p>En el proceso de construcción de sistemas informáticos se pueden distinguir tres fases genéricas:</p>
   <p>•  Fase de definición</p>
   <p>Se identifican los requisitos claves del sistema y del software</p>
   <p>Se desarrolla</p>
   <p>-Un Análisis de Sistemas</p>
   <p>--Se define el papel de cada elemento en el sistema automatizado de información, incluyendo el que jugará el software</p>
   <p>-Un Análisis de Requisitos</p>
   <p>--Se especifican todos los requisitos de usuario que el sistema tiene que satisfacer</p>
   <p>--Esta fase está orientada al QUÉ</p>
   <p>---Qué información ha de ser procesada, qué función y rendimiento se desea, qué interfaces han de establecerse, qué ligaduras de diseño existen y qué criterios de validación se necesitan para definir un sistema correcto</p>
   <p>Existe un paso complementario: la planificación del proyecto software:</p>
   <p>-Se asignan los recursos</p>
   <p>-Se estiman los costos</p>
   <p>-Se planifican las tareas y el trabajo</p>
   <p>•  Fase de desarrollo</p>
   <p>Fase orientada al CÓMO</p>
   <p>El primer paso de esta fase corresponde al Diseño del Software</p>
   <p>-Se trasladan los requisitos del software a un conjunto de representaciones que  describen la estructura de datos, arquitectura del software y procedimientos algorítmicos que permiten la construcción física de dicho software.</p>
   <p>Los otros dos pasos de la fase de desarrollo corresponden a la Codificación y a la Prueba del Software</p>
   <p>•  Fase de mantenimiento</p>
   <p>-Mantenimiento correctivo</p>
   <p>--Corrección de errores</p>
   <p>-Mantenimiento adaptativo</p>
   <p>--Adaptaciones requeridas por la evolución del entorno del software</p>
   <p>-Mantenimiento perfectivo</p>
   <p>--Las modificaciones debidas a los cambios de requisitos del usuario para mejorar el sistema</p>
   <p>-Mantenimiento preventivo</p>
   <p>--Mejora de las características internas del producto para hacer más mantenible</p>

## Configuration

### Sample Posts

Visit the [the demo site](https://lenpaul.github.io/Lagrange/) to find sample posts that show what different types of text formatting look like. You can find these posts in the `_posts` folder, which show what the best practices for setting up your own site are.

### Site Variables

To change site build settings, edit the `_config.yml` file found in the root of your repository, which you can tweak however you like. More information on configuration settings and plugins can be found on [the Jekyll documentation site](https://jekyllrb.com/docs/configuration/). This is also where you will be able to customize the title, description, and the author/owner of your site.

If you are hosting your site on GitHub Pages, then committing a change to the `_config.yml` file will force a rebuild of your site with Jekyll. Any changes made should be viewable soon after. If you are hosting your site locally, then you must run `jekyll serve` again for the changes to take place.

In the `settings.yml` file found in the `_data` folder, you will be able to customize your site settings, such as setting Disqus comments, Google Analytics, what shows up in your menu, and social media information.

### Adding Menu Pages

The menu pages are found in the `menu` folder in the root directory, and can be added to your menu in the `settings.yml` file.

### Posts

You will find example posts in your `_posts` directory. Go ahead and edit any post and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run `jekyll serve`, which launches a web server and auto-regenerates your site when a file is updated.

To add new posts, simply add a file in the `_posts` directory that follows the convention of `YYYY-MM-DD-name-of-post.md` and includes the necessary front matter. Take a look at any sample post to get an idea about how it works. If you already have a website built with Jekyll, simply copy over your posts to migrate to Lagrange.

### Layouts

There are two main layout options that are included with Lagrange: post and page. Layouts are specified through the [YAML front block matter](https://jekyllrb.com/docs/frontmatter/). Any file that contains a YAML front block matter will be processed by Jekyll. For example:

```
---
layout: post
title: "Example Post"
---
```

Examples of what posts looks like can be found in the `_posts` directory, which includes this post you are reading right now. Posts are the basic blog post layout, which includes a header image, post content, author name, date published, social media sharing links, and related posts.

Pages are essentially the post layout without any of the extra features of the posts layout. An example of what pages look like can be found at the [About](https://lenpaul.github.io/Lagrange/menu/about.html) and [Contacts](https://lenpaul.github.io/Lagrange/menu/contact.html).

In addition to the two main layout options above, there are also custom layouts that have been created for the [home page](https://lenpaul.github.io/Lagrange/) and the [archives page](https://lenpaul.github.io/Lagrange/menu/writing.html). These are simply just page layouts with some [Liquid template code](https://shopify.github.io/liquid/). Check out the `index.html` file in the root directory for what the code looks like.

### YAML Front Block Matter

The recommended YAML front block is:

```
---
layout:
title:
author:
categories:
tags: []
image:
---
```

`layout` specifies which layout to use, `title` is the page or post title, `categories` can be used to better organize your posts, `tags` are used when generating related posts based on the topic of the post, and `image` specifies which images to use. Have a look at some posts in the `_posts` directory to see how these variables are set.

## Features

### Design Considerations

Lagrange was designed to be a minimalist theme in order for the focus to remain on your content. For example, links are signified mainly through an underline text-decoration, in order to maximize the perceived affordance of clickability (I originally just wanted to make the links a darker shade of grey).

### Disqus

Lagrange supports comments at the end of posts through [Disqus](https://disqus.com/). In order to activate Disqus commenting, set `disqus.comments` to true in the `_data/settings.yml` file. If you do not have a Disqus account already, you will have to set one up, and create a profile for your website. You will be given a `disqus_shortname` that will be used to generate the appropriate comments sections for your site. More information on [how to set up Disqus](http://www.perfectlyrandom.org/2014/06/29/adding-disqus-to-your-jekyll-powered-github-pages/).

### Google Analytics

It is possible to track your site statistics through [Google Analytics](https://www.google.com/analytics/). Similar to Disqus, you will have to create an account for Google Analytics, and enter the correct Google ID for your site under `google-ID` in the `settings.yml` file. More information on [how to set up Google Analytics](https://michaelsoolee.com/google-analytics-jekyll/).

### RSS Feeds

Atom is supported by default through [jekyll-feed](https://github.com/jekyll/jekyll-feed). With jekyll-feed, you can set configuration variables such as 'title', 'description', and 'author', in the `_config.yml` file.

RSS 2.0 is also supported through [RSS auto-discovery](http://www.rssboard.org/rss-autodiscovery). The `rss-feed.xml` file (based on the template found at [jekyll-rss-feeds](https://github.com/snaptortoise/jekyll-rss-feeds)) that the feed path points to when using RSS 2.0 is automatically generated based on the appropriate configuration variables found in `_data/settings.yml`.

To use RSS 2.0, ensure the following is done:

* Uncomment the last two lines in the `_config.yml` file.

* In `_data/settings.yml`, under 'social', comment out the rss-square that points to `feed.xml`, and uncomment the rss-square that points to `rss-feed.xml`.

* In `_includes/head.html`, comment out `{% feed_meta %}` and uncomment the line under the RSS 2.0 comment.

### Social Media Icons

All social media icons are courtesy of [Font Awesome](http://fontawesome.io/). You can change which icons appear, as well as the account that they link to, in the `settings.yml` file in the `_data` folder.

### MathJax

Lagrange comes out of the box with [MathJax](https://www.mathjax.org/), which allows you to display mathematical equations in your posts through the use of [LaTeX](http://www.andy-roberts.net/writing/latex/mathematics_1).

### Syntax Highlighting

Lagrange provides syntax highlighting through [fenced code blocks](https://help.github.com/articles/creating-and-highlighting-code-blocks/). Syntax highlighting allows you to display source code in different colors and fonts depending on what programming language is being displayed. You can find the full list of supported programming languages [here](https://github.com/jneen/rouge/wiki/List-of-supported-languages-and-lexers). Another option is to embed your code through [Gist](https://en.support.wordpress.com/gist/).

### Markdown

As always, Jekyll offers support for GitHub Flavored Markdown, which allows you to format your posts using the [Markdown syntax](https://guides.github.com/features/mastering-markdown/). Examples of these text formatting features can be seen below. You can find this post in the `_posts` directory as well as the `README.md` file.

## Everything Else

Check out the [Jekyll docs][jekyll-docs] for more info on how to get the most out of Jekyll. File all bugs/feature requests at [Jekyll's GitHub repo][jekyll-gh]. If you have questions, you can ask them on [Jekyll Talk][jekyll-talk].

[jekyll-docs]: http://jekyllrb.com/docs/home
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/

## Contributing

If you would like to make a feature request, or report a bug or typo in the documentation, then please [submit a GitHub issue](https://github.com/LeNPaul/Lagrange/issues/new). If you would like to make a contribution, then feel free to [submit a pull request](https://help.github.com/articles/about-pull-requests/) - as a bonus, I will credit all contributors below! If this is your first pull request, it may be helpful to read up on the [GitHub Flow](https://guides.github.com/introduction/flow/) first.

Lagrange has been designed as a base for users to customize and fit to their own unique needs. Please keep this in mind when requesting features and/or submitting pull requests. Some examples of changes that I would love to see are things that would make the site easier to use, or better ways of doing things. Please avoid changes that do not benefit the majority of users.

## Questions?

This theme is completely free and open source software. You may use it however you want, as it is distributed under the [MIT License](http://choosealicense.com/licenses/mit/). If you are having any problems, any questions or suggestions, feel free to [tweet at me](https://twitter.com/intent/tweet?text=My%question%about%Lagrange%is:%&amp;via=paululele), or [file a GitHub issue](https://github.com/lenpaul/lagrange/issues/new).

## Credits

### Creator

#### Paul Le

* [www.lenpaul.com](http://lenpaul.com)

* [Twitter](https://twitter.com/paululele)

* [GitHub](https://github.com/LeNPaul)

### Contributors

* [nikolalukovic](https://github.com/nikolalukovic)

* [gmemstr](https://github.com/gmemstr)

* [lynn9388](https://github.com/lynn9388)

* [robqiao](https://github.com/robqiao)

* [Mauladen](https://github.com/Mauladen)

* [dhanus](https://github.com/dhanus)

* [mlewand](https://github.com/mlewand)

* [Hguimaraes](https://github.com/Hguimaraes)

* [ilhamadun](https://github.com/ilhamadun)

* [brianclemens](https://github.com/brianclemens)

* [leyhline](https://github.com/leyhline)

* [aritra24](https://github.com/aritra24)

* [DuckSoft](https://github.com/DuckSoft)

### Icons + Demo Images

* [Death to Stock](https://deathtothestockphoto.com/)

* [Font Awesome](http://fontawesome.io/)

### Other

* [Jekyll](https://jekyllrb.com/)

* [Free Code Camp](https://www.freecodecamp.org)

* [Khan Academy](https://www.khanacademy.org/)

## License

Open sourced under the [MIT license](https://github.com/LeNPaul/Lagrange/blob/gh-pages/LICENSE.md).
